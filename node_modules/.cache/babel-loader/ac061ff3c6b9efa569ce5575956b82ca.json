{"ast":null,"code":"'use strict';\n\nvar emitter = require('contra/emitter');\n\nvar crossvent = require('crossvent');\n\nvar classes = require('./classes');\n\nvar doc = document;\nvar documentElement = doc.documentElement;\n\nfunction dragula(initialContainers, options) {\n  var len = arguments.length;\n\n  if (len === 1 && Array.isArray(initialContainers) === false) {\n    options = initialContainers;\n    initialContainers = [];\n  }\n\n  var _mirror; // mirror image\n\n\n  var _source; // source container\n\n\n  var _item; // item being dragged\n\n\n  var _offsetX; // reference x\n\n\n  var _offsetY; // reference y\n\n\n  var _moveX; // reference move x\n\n\n  var _moveY; // reference move y\n\n\n  var _initialSibling; // reference sibling when grabbed\n\n\n  var _currentSibling; // reference sibling now\n\n\n  var _copy; // item used for copying\n\n\n  var _renderTimer; // timer for setTimeout renderMirrorImage\n\n\n  var _lastDropTarget = null; // last container item was over\n\n  var _grabbed; // holds mousedown context until first mousemove\n\n\n  var o = options || {};\n\n  if (o.moves === void 0) {\n    o.moves = always;\n  }\n\n  if (o.accepts === void 0) {\n    o.accepts = always;\n  }\n\n  if (o.invalid === void 0) {\n    o.invalid = invalidTarget;\n  }\n\n  if (o.containers === void 0) {\n    o.containers = initialContainers || [];\n  }\n\n  if (o.isContainer === void 0) {\n    o.isContainer = never;\n  }\n\n  if (o.copy === void 0) {\n    o.copy = false;\n  }\n\n  if (o.copySortSource === void 0) {\n    o.copySortSource = false;\n  }\n\n  if (o.revertOnSpill === void 0) {\n    o.revertOnSpill = false;\n  }\n\n  if (o.removeOnSpill === void 0) {\n    o.removeOnSpill = false;\n  }\n\n  if (o.direction === void 0) {\n    o.direction = 'vertical';\n  }\n\n  if (o.ignoreInputTextSelection === void 0) {\n    o.ignoreInputTextSelection = true;\n  }\n\n  if (o.mirrorContainer === void 0) {\n    o.mirrorContainer = doc.body;\n  }\n\n  var drake = emitter({\n    containers: o.containers,\n    start: manualStart,\n    end: end,\n    cancel: cancel,\n    remove: remove,\n    destroy: destroy,\n    canMove: canMove,\n    dragging: false\n  });\n\n  if (o.removeOnSpill === true) {\n    drake.on('over', spillOver).on('out', spillOut);\n  }\n\n  events();\n  return drake;\n\n  function isContainer(el) {\n    return drake.containers.indexOf(el) !== -1 || o.isContainer(el);\n  }\n\n  function events(remove) {\n    var op = remove ? 'remove' : 'add';\n    touchy(documentElement, op, 'mousedown', grab);\n    touchy(documentElement, op, 'mouseup', release);\n  }\n\n  function eventualMovements(remove) {\n    var op = remove ? 'remove' : 'add';\n    touchy(documentElement, op, 'mousemove', startBecauseMouseMoved);\n  }\n\n  function movements(remove) {\n    var op = remove ? 'remove' : 'add';\n    crossvent[op](documentElement, 'selectstart', preventGrabbed); // IE8\n\n    crossvent[op](documentElement, 'click', preventGrabbed);\n  }\n\n  function destroy() {\n    events(true);\n    release({});\n  }\n\n  function preventGrabbed(e) {\n    if (_grabbed) {\n      e.preventDefault();\n    }\n  }\n\n  function grab(e) {\n    _moveX = e.clientX;\n    _moveY = e.clientY;\n    var ignore = whichMouseButton(e) !== 1 || e.metaKey || e.ctrlKey;\n\n    if (ignore) {\n      return; // we only care about honest-to-god left clicks and touch events\n    }\n\n    var item = e.target;\n    var context = canStart(item);\n\n    if (!context) {\n      return;\n    }\n\n    _grabbed = context;\n    eventualMovements();\n\n    if (e.type === 'mousedown') {\n      if (isInput(item)) {\n        // see also: https://github.com/bevacqua/dragula/issues/208\n        item.focus(); // fixes https://github.com/bevacqua/dragula/issues/176\n      } else {\n        e.preventDefault(); // fixes https://github.com/bevacqua/dragula/issues/155\n      }\n    }\n  }\n\n  function startBecauseMouseMoved(e) {\n    if (!_grabbed) {\n      return;\n    }\n\n    if (whichMouseButton(e) === 0) {\n      release({});\n      return; // when text is selected on an input and then dragged, mouseup doesn't fire. this is our only hope\n    } // truthy check fixes #239, equality fixes #207, fixes #501\n\n\n    if (e.clientX !== void 0 && Math.abs(e.clientX - _moveX) <= (o.slideFactorX || 0) && e.clientY !== void 0 && Math.abs(e.clientY - _moveY) <= (o.slideFactorY || 0)) {\n      return;\n    }\n\n    if (o.ignoreInputTextSelection) {\n      var clientX = getCoord('clientX', e) || 0;\n      var clientY = getCoord('clientY', e) || 0;\n      var elementBehindCursor = doc.elementFromPoint(clientX, clientY);\n\n      if (isInput(elementBehindCursor)) {\n        return;\n      }\n    }\n\n    var grabbed = _grabbed; // call to end() unsets _grabbed\n\n    eventualMovements(true);\n    movements();\n    end();\n    start(grabbed);\n    var offset = getOffset(_item);\n    _offsetX = getCoord('pageX', e) - offset.left;\n    _offsetY = getCoord('pageY', e) - offset.top;\n    classes.add(_copy || _item, 'gu-transit');\n    renderMirrorImage();\n    drag(e);\n  }\n\n  function canStart(item) {\n    if (drake.dragging && _mirror) {\n      return;\n    }\n\n    if (isContainer(item)) {\n      return; // don't drag container itself\n    }\n\n    var handle = item;\n\n    while (getParent(item) && isContainer(getParent(item)) === false) {\n      if (o.invalid(item, handle)) {\n        return;\n      }\n\n      item = getParent(item); // drag target should be a top element\n\n      if (!item) {\n        return;\n      }\n    }\n\n    var source = getParent(item);\n\n    if (!source) {\n      return;\n    }\n\n    if (o.invalid(item, handle)) {\n      return;\n    }\n\n    var movable = o.moves(item, source, handle, nextEl(item));\n\n    if (!movable) {\n      return;\n    }\n\n    return {\n      item: item,\n      source: source\n    };\n  }\n\n  function canMove(item) {\n    return !!canStart(item);\n  }\n\n  function manualStart(item) {\n    var context = canStart(item);\n\n    if (context) {\n      start(context);\n    }\n  }\n\n  function start(context) {\n    if (isCopy(context.item, context.source)) {\n      _copy = context.item.cloneNode(true);\n      drake.emit('cloned', _copy, context.item, 'copy');\n    }\n\n    _source = context.source;\n    _item = context.item;\n    _initialSibling = _currentSibling = nextEl(context.item);\n    drake.dragging = true;\n    drake.emit('drag', _item, _source);\n  }\n\n  function invalidTarget() {\n    return false;\n  }\n\n  function end() {\n    if (!drake.dragging) {\n      return;\n    }\n\n    var item = _copy || _item;\n    drop(item, getParent(item));\n  }\n\n  function ungrab() {\n    _grabbed = false;\n    eventualMovements(true);\n    movements(true);\n  }\n\n  function release(e) {\n    ungrab();\n\n    if (!drake.dragging) {\n      return;\n    }\n\n    var item = _copy || _item;\n    var clientX = getCoord('clientX', e) || 0;\n    var clientY = getCoord('clientY', e) || 0;\n    var elementBehindCursor = getElementBehindPoint(_mirror, clientX, clientY);\n    var dropTarget = findDropTarget(elementBehindCursor, clientX, clientY);\n\n    if (dropTarget && (_copy && o.copySortSource || !_copy || dropTarget !== _source)) {\n      drop(item, dropTarget);\n    } else if (o.removeOnSpill) {\n      remove();\n    } else {\n      cancel();\n    }\n  }\n\n  function drop(item, target) {\n    var parent = getParent(item);\n\n    if (_copy && o.copySortSource && target === _source) {\n      parent.removeChild(_item);\n    }\n\n    if (isInitialPlacement(target)) {\n      drake.emit('cancel', item, _source, _source);\n    } else {\n      drake.emit('drop', item, target, _source, _currentSibling);\n    }\n\n    cleanup();\n  }\n\n  function remove() {\n    if (!drake.dragging) {\n      return;\n    }\n\n    var item = _copy || _item;\n    var parent = getParent(item);\n\n    if (parent) {\n      parent.removeChild(item);\n    }\n\n    drake.emit(_copy ? 'cancel' : 'remove', item, parent, _source);\n    cleanup();\n  }\n\n  function cancel(revert) {\n    if (!drake.dragging) {\n      return;\n    }\n\n    var reverts = arguments.length > 0 ? revert : o.revertOnSpill;\n    var item = _copy || _item;\n    var parent = getParent(item);\n    var initial = isInitialPlacement(parent);\n\n    if (initial === false && reverts) {\n      if (_copy) {\n        if (parent) {\n          parent.removeChild(_copy);\n        }\n      } else {\n        _source.insertBefore(item, _initialSibling);\n      }\n    }\n\n    if (initial || reverts) {\n      drake.emit('cancel', item, _source, _source);\n    } else {\n      drake.emit('drop', item, parent, _source, _currentSibling);\n    }\n\n    cleanup();\n  }\n\n  function cleanup() {\n    var item = _copy || _item;\n    ungrab();\n    removeMirrorImage();\n\n    if (item) {\n      classes.rm(item, 'gu-transit');\n    }\n\n    if (_renderTimer) {\n      clearTimeout(_renderTimer);\n    }\n\n    drake.dragging = false;\n\n    if (_lastDropTarget) {\n      drake.emit('out', item, _lastDropTarget, _source);\n    }\n\n    drake.emit('dragend', item);\n    _source = _item = _copy = _initialSibling = _currentSibling = _renderTimer = _lastDropTarget = null;\n  }\n\n  function isInitialPlacement(target, s) {\n    var sibling;\n\n    if (s !== void 0) {\n      sibling = s;\n    } else if (_mirror) {\n      sibling = _currentSibling;\n    } else {\n      sibling = nextEl(_copy || _item);\n    }\n\n    return target === _source && sibling === _initialSibling;\n  }\n\n  function findDropTarget(elementBehindCursor, clientX, clientY) {\n    var target = elementBehindCursor;\n\n    while (target && !accepted()) {\n      target = getParent(target);\n    }\n\n    return target;\n\n    function accepted() {\n      var droppable = isContainer(target);\n\n      if (droppable === false) {\n        return false;\n      }\n\n      var immediate = getImmediateChild(target, elementBehindCursor);\n      var reference = getReference(target, immediate, clientX, clientY);\n      var initial = isInitialPlacement(target, reference);\n\n      if (initial) {\n        return true; // should always be able to drop it right back where it was\n      }\n\n      return o.accepts(_item, target, _source, reference);\n    }\n  }\n\n  function drag(e) {\n    if (!_mirror) {\n      return;\n    }\n\n    e.preventDefault();\n    var clientX = getCoord('clientX', e) || 0;\n    var clientY = getCoord('clientY', e) || 0;\n    var x = clientX - _offsetX;\n    var y = clientY - _offsetY;\n    _mirror.style.left = x + 'px';\n    _mirror.style.top = y + 'px';\n    var item = _copy || _item;\n    var elementBehindCursor = getElementBehindPoint(_mirror, clientX, clientY);\n    var dropTarget = findDropTarget(elementBehindCursor, clientX, clientY);\n    var changed = dropTarget !== null && dropTarget !== _lastDropTarget;\n\n    if (changed || dropTarget === null) {\n      out();\n      _lastDropTarget = dropTarget;\n      over();\n    }\n\n    var parent = getParent(item);\n\n    if (dropTarget === _source && _copy && !o.copySortSource) {\n      if (parent) {\n        parent.removeChild(item);\n      }\n\n      return;\n    }\n\n    var reference;\n    var immediate = getImmediateChild(dropTarget, elementBehindCursor);\n\n    if (immediate !== null) {\n      reference = getReference(dropTarget, immediate, clientX, clientY);\n    } else if (o.revertOnSpill === true && !_copy) {\n      reference = _initialSibling;\n      dropTarget = _source;\n    } else {\n      if (_copy && parent) {\n        parent.removeChild(item);\n      }\n\n      return;\n    }\n\n    if (reference === null && changed || reference !== item && reference !== nextEl(item)) {\n      _currentSibling = reference;\n      dropTarget.insertBefore(item, reference);\n      drake.emit('shadow', item, dropTarget, _source);\n    }\n\n    function moved(type) {\n      drake.emit(type, item, _lastDropTarget, _source);\n    }\n\n    function over() {\n      if (changed) {\n        moved('over');\n      }\n    }\n\n    function out() {\n      if (_lastDropTarget) {\n        moved('out');\n      }\n    }\n  }\n\n  function spillOver(el) {\n    classes.rm(el, 'gu-hide');\n  }\n\n  function spillOut(el) {\n    if (drake.dragging) {\n      classes.add(el, 'gu-hide');\n    }\n  }\n\n  function renderMirrorImage() {\n    if (_mirror) {\n      return;\n    }\n\n    var rect = _item.getBoundingClientRect();\n\n    _mirror = _item.cloneNode(true);\n    _mirror.style.width = getRectWidth(rect) + 'px';\n    _mirror.style.height = getRectHeight(rect) + 'px';\n    classes.rm(_mirror, 'gu-transit');\n    classes.add(_mirror, 'gu-mirror');\n    o.mirrorContainer.appendChild(_mirror);\n    touchy(documentElement, 'add', 'mousemove', drag);\n    classes.add(o.mirrorContainer, 'gu-unselectable');\n    drake.emit('cloned', _mirror, _item, 'mirror');\n  }\n\n  function removeMirrorImage() {\n    if (_mirror) {\n      classes.rm(o.mirrorContainer, 'gu-unselectable');\n      touchy(documentElement, 'remove', 'mousemove', drag);\n      getParent(_mirror).removeChild(_mirror);\n      _mirror = null;\n    }\n  }\n\n  function getImmediateChild(dropTarget, target) {\n    var immediate = target;\n\n    while (immediate !== dropTarget && getParent(immediate) !== dropTarget) {\n      immediate = getParent(immediate);\n    }\n\n    if (immediate === documentElement) {\n      return null;\n    }\n\n    return immediate;\n  }\n\n  function getReference(dropTarget, target, x, y) {\n    var horizontal = o.direction === 'horizontal';\n    var reference = target !== dropTarget ? inside() : outside();\n    return reference;\n\n    function outside() {\n      // slower, but able to figure out any position\n      var len = dropTarget.children.length;\n      var i;\n      var el;\n      var rect;\n\n      for (i = 0; i < len; i++) {\n        el = dropTarget.children[i];\n        rect = el.getBoundingClientRect();\n\n        if (horizontal && rect.left + rect.width / 2 > x) {\n          return el;\n        }\n\n        if (!horizontal && rect.top + rect.height / 2 > y) {\n          return el;\n        }\n      }\n\n      return null;\n    }\n\n    function inside() {\n      // faster, but only available if dropped inside a child element\n      var rect = target.getBoundingClientRect();\n\n      if (horizontal) {\n        return resolve(x > rect.left + getRectWidth(rect) / 2);\n      }\n\n      return resolve(y > rect.top + getRectHeight(rect) / 2);\n    }\n\n    function resolve(after) {\n      return after ? nextEl(target) : target;\n    }\n  }\n\n  function isCopy(item, container) {\n    return typeof o.copy === 'boolean' ? o.copy : o.copy(item, container);\n  }\n}\n\nfunction touchy(el, op, type, fn) {\n  var touch = {\n    mouseup: 'touchend',\n    mousedown: 'touchstart',\n    mousemove: 'touchmove'\n  };\n  var pointers = {\n    mouseup: 'pointerup',\n    mousedown: 'pointerdown',\n    mousemove: 'pointermove'\n  };\n  var microsoft = {\n    mouseup: 'MSPointerUp',\n    mousedown: 'MSPointerDown',\n    mousemove: 'MSPointerMove'\n  };\n\n  if (global.navigator.pointerEnabled) {\n    crossvent[op](el, pointers[type], fn);\n  } else if (global.navigator.msPointerEnabled) {\n    crossvent[op](el, microsoft[type], fn);\n  } else {\n    crossvent[op](el, touch[type], fn);\n    crossvent[op](el, type, fn);\n  }\n}\n\nfunction whichMouseButton(e) {\n  if (e.touches !== void 0) {\n    return e.touches.length;\n  }\n\n  if (e.which !== void 0 && e.which !== 0) {\n    return e.which;\n  } // see https://github.com/bevacqua/dragula/issues/261\n\n\n  if (e.buttons !== void 0) {\n    return e.buttons;\n  }\n\n  var button = e.button;\n\n  if (button !== void 0) {\n    // see https://github.com/jquery/jquery/blob/99e8ff1baa7ae341e94bb89c3e84570c7c3ad9ea/src/event.js#L573-L575\n    return button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;\n  }\n}\n\nfunction getOffset(el) {\n  var rect = el.getBoundingClientRect();\n  return {\n    left: rect.left + getScroll('scrollLeft', 'pageXOffset'),\n    top: rect.top + getScroll('scrollTop', 'pageYOffset')\n  };\n}\n\nfunction getScroll(scrollProp, offsetProp) {\n  if (typeof global[offsetProp] !== 'undefined') {\n    return global[offsetProp];\n  }\n\n  if (documentElement.clientHeight) {\n    return documentElement[scrollProp];\n  }\n\n  return doc.body[scrollProp];\n}\n\nfunction getElementBehindPoint(point, x, y) {\n  point = point || {};\n  var state = point.className || '';\n  var el;\n  point.className += ' gu-hide';\n  el = doc.elementFromPoint(x, y);\n  point.className = state;\n  return el;\n}\n\nfunction never() {\n  return false;\n}\n\nfunction always() {\n  return true;\n}\n\nfunction getRectWidth(rect) {\n  return rect.width || rect.right - rect.left;\n}\n\nfunction getRectHeight(rect) {\n  return rect.height || rect.bottom - rect.top;\n}\n\nfunction getParent(el) {\n  return el.parentNode === doc ? null : el.parentNode;\n}\n\nfunction isInput(el) {\n  return el.tagName === 'INPUT' || el.tagName === 'TEXTAREA' || el.tagName === 'SELECT' || isEditable(el);\n}\n\nfunction isEditable(el) {\n  if (!el) {\n    return false;\n  } // no parents were editable\n\n\n  if (el.contentEditable === 'false') {\n    return false;\n  } // stop the lookup\n\n\n  if (el.contentEditable === 'true') {\n    return true;\n  } // found a contentEditable element in the chain\n\n\n  return isEditable(getParent(el)); // contentEditable is set to 'inherit'\n}\n\nfunction nextEl(el) {\n  return el.nextElementSibling || manually();\n\n  function manually() {\n    var sibling = el;\n\n    do {\n      sibling = sibling.nextSibling;\n    } while (sibling && sibling.nodeType !== 1);\n\n    return sibling;\n  }\n}\n\nfunction getEventHost(e) {\n  // on touchend event, we have to use `e.changedTouches`\n  // see http://stackoverflow.com/questions/7192563/touchend-event-properties\n  // see https://github.com/bevacqua/dragula/issues/34\n  if (e.targetTouches && e.targetTouches.length) {\n    return e.targetTouches[0];\n  }\n\n  if (e.changedTouches && e.changedTouches.length) {\n    return e.changedTouches[0];\n  }\n\n  return e;\n}\n\nfunction getCoord(coord, e) {\n  var host = getEventHost(e);\n  var missMap = {\n    pageX: 'clientX',\n    // IE8\n    pageY: 'clientY' // IE8\n\n  };\n\n  if (coord in missMap && !(coord in host) && missMap[coord] in host) {\n    coord = missMap[coord];\n  }\n\n  return host[coord];\n}\n\nmodule.exports = dragula;","map":{"version":3,"sources":["/Users/nasirkhalid/first/node_modules/dragula/dragula.js"],"names":["emitter","require","crossvent","classes","doc","document","documentElement","dragula","initialContainers","options","len","arguments","length","Array","isArray","_mirror","_source","_item","_offsetX","_offsetY","_moveX","_moveY","_initialSibling","_currentSibling","_copy","_renderTimer","_lastDropTarget","_grabbed","o","moves","always","accepts","invalid","invalidTarget","containers","isContainer","never","copy","copySortSource","revertOnSpill","removeOnSpill","direction","ignoreInputTextSelection","mirrorContainer","body","drake","start","manualStart","end","cancel","remove","destroy","canMove","dragging","on","spillOver","spillOut","events","el","indexOf","op","touchy","grab","release","eventualMovements","startBecauseMouseMoved","movements","preventGrabbed","e","preventDefault","clientX","clientY","ignore","whichMouseButton","metaKey","ctrlKey","item","target","context","canStart","type","isInput","focus","Math","abs","slideFactorX","slideFactorY","getCoord","elementBehindCursor","elementFromPoint","grabbed","offset","getOffset","left","top","add","renderMirrorImage","drag","handle","getParent","source","movable","nextEl","isCopy","cloneNode","emit","drop","ungrab","getElementBehindPoint","dropTarget","findDropTarget","parent","removeChild","isInitialPlacement","cleanup","revert","reverts","initial","insertBefore","removeMirrorImage","rm","clearTimeout","s","sibling","accepted","droppable","immediate","getImmediateChild","reference","getReference","x","y","style","changed","out","over","moved","rect","getBoundingClientRect","width","getRectWidth","height","getRectHeight","appendChild","horizontal","inside","outside","children","i","resolve","after","container","fn","touch","mouseup","mousedown","mousemove","pointers","microsoft","global","navigator","pointerEnabled","msPointerEnabled","touches","which","buttons","button","getScroll","scrollProp","offsetProp","clientHeight","point","state","className","right","bottom","parentNode","tagName","isEditable","contentEditable","nextElementSibling","manually","nextSibling","nodeType","getEventHost","targetTouches","changedTouches","coord","host","missMap","pageX","pageY","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar emitter = require('contra/emitter');\nvar crossvent = require('crossvent');\nvar classes = require('./classes');\nvar doc = document;\nvar documentElement = doc.documentElement;\n\nfunction dragula (initialContainers, options) {\n  var len = arguments.length;\n  if (len === 1 && Array.isArray(initialContainers) === false) {\n    options = initialContainers;\n    initialContainers = [];\n  }\n  var _mirror; // mirror image\n  var _source; // source container\n  var _item; // item being dragged\n  var _offsetX; // reference x\n  var _offsetY; // reference y\n  var _moveX; // reference move x\n  var _moveY; // reference move y\n  var _initialSibling; // reference sibling when grabbed\n  var _currentSibling; // reference sibling now\n  var _copy; // item used for copying\n  var _renderTimer; // timer for setTimeout renderMirrorImage\n  var _lastDropTarget = null; // last container item was over\n  var _grabbed; // holds mousedown context until first mousemove\n\n  var o = options || {};\n  if (o.moves === void 0) { o.moves = always; }\n  if (o.accepts === void 0) { o.accepts = always; }\n  if (o.invalid === void 0) { o.invalid = invalidTarget; }\n  if (o.containers === void 0) { o.containers = initialContainers || []; }\n  if (o.isContainer === void 0) { o.isContainer = never; }\n  if (o.copy === void 0) { o.copy = false; }\n  if (o.copySortSource === void 0) { o.copySortSource = false; }\n  if (o.revertOnSpill === void 0) { o.revertOnSpill = false; }\n  if (o.removeOnSpill === void 0) { o.removeOnSpill = false; }\n  if (o.direction === void 0) { o.direction = 'vertical'; }\n  if (o.ignoreInputTextSelection === void 0) { o.ignoreInputTextSelection = true; }\n  if (o.mirrorContainer === void 0) { o.mirrorContainer = doc.body; }\n\n  var drake = emitter({\n    containers: o.containers,\n    start: manualStart,\n    end: end,\n    cancel: cancel,\n    remove: remove,\n    destroy: destroy,\n    canMove: canMove,\n    dragging: false\n  });\n\n  if (o.removeOnSpill === true) {\n    drake.on('over', spillOver).on('out', spillOut);\n  }\n\n  events();\n\n  return drake;\n\n  function isContainer (el) {\n    return drake.containers.indexOf(el) !== -1 || o.isContainer(el);\n  }\n\n  function events (remove) {\n    var op = remove ? 'remove' : 'add';\n    touchy(documentElement, op, 'mousedown', grab);\n    touchy(documentElement, op, 'mouseup', release);\n  }\n\n  function eventualMovements (remove) {\n    var op = remove ? 'remove' : 'add';\n    touchy(documentElement, op, 'mousemove', startBecauseMouseMoved);\n  }\n\n  function movements (remove) {\n    var op = remove ? 'remove' : 'add';\n    crossvent[op](documentElement, 'selectstart', preventGrabbed); // IE8\n    crossvent[op](documentElement, 'click', preventGrabbed);\n  }\n\n  function destroy () {\n    events(true);\n    release({});\n  }\n\n  function preventGrabbed (e) {\n    if (_grabbed) {\n      e.preventDefault();\n    }\n  }\n\n  function grab (e) {\n    _moveX = e.clientX;\n    _moveY = e.clientY;\n\n    var ignore = whichMouseButton(e) !== 1 || e.metaKey || e.ctrlKey;\n    if (ignore) {\n      return; // we only care about honest-to-god left clicks and touch events\n    }\n    var item = e.target;\n    var context = canStart(item);\n    if (!context) {\n      return;\n    }\n    _grabbed = context;\n    eventualMovements();\n    if (e.type === 'mousedown') {\n      if (isInput(item)) { // see also: https://github.com/bevacqua/dragula/issues/208\n        item.focus(); // fixes https://github.com/bevacqua/dragula/issues/176\n      } else {\n        e.preventDefault(); // fixes https://github.com/bevacqua/dragula/issues/155\n      }\n    }\n  }\n\n  function startBecauseMouseMoved (e) {\n    if (!_grabbed) {\n      return;\n    }\n    if (whichMouseButton(e) === 0) {\n      release({});\n      return; // when text is selected on an input and then dragged, mouseup doesn't fire. this is our only hope\n    }\n\n    // truthy check fixes #239, equality fixes #207, fixes #501\n    if ((e.clientX !== void 0 && Math.abs(e.clientX - _moveX) <= (o.slideFactorX || 0)) &&\n      (e.clientY !== void 0 && Math.abs(e.clientY - _moveY) <= (o.slideFactorY || 0))) {\n      return;\n    }\n\n    if (o.ignoreInputTextSelection) {\n      var clientX = getCoord('clientX', e) || 0;\n      var clientY = getCoord('clientY', e) || 0;\n      var elementBehindCursor = doc.elementFromPoint(clientX, clientY);\n      if (isInput(elementBehindCursor)) {\n        return;\n      }\n    }\n\n    var grabbed = _grabbed; // call to end() unsets _grabbed\n    eventualMovements(true);\n    movements();\n    end();\n    start(grabbed);\n\n    var offset = getOffset(_item);\n    _offsetX = getCoord('pageX', e) - offset.left;\n    _offsetY = getCoord('pageY', e) - offset.top;\n\n    classes.add(_copy || _item, 'gu-transit');\n    renderMirrorImage();\n    drag(e);\n  }\n\n  function canStart (item) {\n    if (drake.dragging && _mirror) {\n      return;\n    }\n    if (isContainer(item)) {\n      return; // don't drag container itself\n    }\n    var handle = item;\n    while (getParent(item) && isContainer(getParent(item)) === false) {\n      if (o.invalid(item, handle)) {\n        return;\n      }\n      item = getParent(item); // drag target should be a top element\n      if (!item) {\n        return;\n      }\n    }\n    var source = getParent(item);\n    if (!source) {\n      return;\n    }\n    if (o.invalid(item, handle)) {\n      return;\n    }\n\n    var movable = o.moves(item, source, handle, nextEl(item));\n    if (!movable) {\n      return;\n    }\n\n    return {\n      item: item,\n      source: source\n    };\n  }\n\n  function canMove (item) {\n    return !!canStart(item);\n  }\n\n  function manualStart (item) {\n    var context = canStart(item);\n    if (context) {\n      start(context);\n    }\n  }\n\n  function start (context) {\n    if (isCopy(context.item, context.source)) {\n      _copy = context.item.cloneNode(true);\n      drake.emit('cloned', _copy, context.item, 'copy');\n    }\n\n    _source = context.source;\n    _item = context.item;\n    _initialSibling = _currentSibling = nextEl(context.item);\n\n    drake.dragging = true;\n    drake.emit('drag', _item, _source);\n  }\n\n  function invalidTarget () {\n    return false;\n  }\n\n  function end () {\n    if (!drake.dragging) {\n      return;\n    }\n    var item = _copy || _item;\n    drop(item, getParent(item));\n  }\n\n  function ungrab () {\n    _grabbed = false;\n    eventualMovements(true);\n    movements(true);\n  }\n\n  function release (e) {\n    ungrab();\n\n    if (!drake.dragging) {\n      return;\n    }\n    var item = _copy || _item;\n    var clientX = getCoord('clientX', e) || 0;\n    var clientY = getCoord('clientY', e) || 0;\n    var elementBehindCursor = getElementBehindPoint(_mirror, clientX, clientY);\n    var dropTarget = findDropTarget(elementBehindCursor, clientX, clientY);\n    if (dropTarget && ((_copy && o.copySortSource) || (!_copy || dropTarget !== _source))) {\n      drop(item, dropTarget);\n    } else if (o.removeOnSpill) {\n      remove();\n    } else {\n      cancel();\n    }\n  }\n\n  function drop (item, target) {\n    var parent = getParent(item);\n    if (_copy && o.copySortSource && target === _source) {\n      parent.removeChild(_item);\n    }\n    if (isInitialPlacement(target)) {\n      drake.emit('cancel', item, _source, _source);\n    } else {\n      drake.emit('drop', item, target, _source, _currentSibling);\n    }\n    cleanup();\n  }\n\n  function remove () {\n    if (!drake.dragging) {\n      return;\n    }\n    var item = _copy || _item;\n    var parent = getParent(item);\n    if (parent) {\n      parent.removeChild(item);\n    }\n    drake.emit(_copy ? 'cancel' : 'remove', item, parent, _source);\n    cleanup();\n  }\n\n  function cancel (revert) {\n    if (!drake.dragging) {\n      return;\n    }\n    var reverts = arguments.length > 0 ? revert : o.revertOnSpill;\n    var item = _copy || _item;\n    var parent = getParent(item);\n    var initial = isInitialPlacement(parent);\n    if (initial === false && reverts) {\n      if (_copy) {\n        if (parent) {\n          parent.removeChild(_copy);\n        }\n      } else {\n        _source.insertBefore(item, _initialSibling);\n      }\n    }\n    if (initial || reverts) {\n      drake.emit('cancel', item, _source, _source);\n    } else {\n      drake.emit('drop', item, parent, _source, _currentSibling);\n    }\n    cleanup();\n  }\n\n  function cleanup () {\n    var item = _copy || _item;\n    ungrab();\n    removeMirrorImage();\n    if (item) {\n      classes.rm(item, 'gu-transit');\n    }\n    if (_renderTimer) {\n      clearTimeout(_renderTimer);\n    }\n    drake.dragging = false;\n    if (_lastDropTarget) {\n      drake.emit('out', item, _lastDropTarget, _source);\n    }\n    drake.emit('dragend', item);\n    _source = _item = _copy = _initialSibling = _currentSibling = _renderTimer = _lastDropTarget = null;\n  }\n\n  function isInitialPlacement (target, s) {\n    var sibling;\n    if (s !== void 0) {\n      sibling = s;\n    } else if (_mirror) {\n      sibling = _currentSibling;\n    } else {\n      sibling = nextEl(_copy || _item);\n    }\n    return target === _source && sibling === _initialSibling;\n  }\n\n  function findDropTarget (elementBehindCursor, clientX, clientY) {\n    var target = elementBehindCursor;\n    while (target && !accepted()) {\n      target = getParent(target);\n    }\n    return target;\n\n    function accepted () {\n      var droppable = isContainer(target);\n      if (droppable === false) {\n        return false;\n      }\n\n      var immediate = getImmediateChild(target, elementBehindCursor);\n      var reference = getReference(target, immediate, clientX, clientY);\n      var initial = isInitialPlacement(target, reference);\n      if (initial) {\n        return true; // should always be able to drop it right back where it was\n      }\n      return o.accepts(_item, target, _source, reference);\n    }\n  }\n\n  function drag (e) {\n    if (!_mirror) {\n      return;\n    }\n    e.preventDefault();\n\n    var clientX = getCoord('clientX', e) || 0;\n    var clientY = getCoord('clientY', e) || 0;\n    var x = clientX - _offsetX;\n    var y = clientY - _offsetY;\n\n    _mirror.style.left = x + 'px';\n    _mirror.style.top = y + 'px';\n\n    var item = _copy || _item;\n    var elementBehindCursor = getElementBehindPoint(_mirror, clientX, clientY);\n    var dropTarget = findDropTarget(elementBehindCursor, clientX, clientY);\n    var changed = dropTarget !== null && dropTarget !== _lastDropTarget;\n    if (changed || dropTarget === null) {\n      out();\n      _lastDropTarget = dropTarget;\n      over();\n    }\n    var parent = getParent(item);\n    if (dropTarget === _source && _copy && !o.copySortSource) {\n      if (parent) {\n        parent.removeChild(item);\n      }\n      return;\n    }\n    var reference;\n    var immediate = getImmediateChild(dropTarget, elementBehindCursor);\n    if (immediate !== null) {\n      reference = getReference(dropTarget, immediate, clientX, clientY);\n    } else if (o.revertOnSpill === true && !_copy) {\n      reference = _initialSibling;\n      dropTarget = _source;\n    } else {\n      if (_copy && parent) {\n        parent.removeChild(item);\n      }\n      return;\n    }\n    if (\n      (reference === null && changed) ||\n      reference !== item &&\n      reference !== nextEl(item)\n    ) {\n      _currentSibling = reference;\n      dropTarget.insertBefore(item, reference);\n      drake.emit('shadow', item, dropTarget, _source);\n    }\n    function moved (type) { drake.emit(type, item, _lastDropTarget, _source); }\n    function over () { if (changed) { moved('over'); } }\n    function out () { if (_lastDropTarget) { moved('out'); } }\n  }\n\n  function spillOver (el) {\n    classes.rm(el, 'gu-hide');\n  }\n\n  function spillOut (el) {\n    if (drake.dragging) { classes.add(el, 'gu-hide'); }\n  }\n\n  function renderMirrorImage () {\n    if (_mirror) {\n      return;\n    }\n    var rect = _item.getBoundingClientRect();\n    _mirror = _item.cloneNode(true);\n    _mirror.style.width = getRectWidth(rect) + 'px';\n    _mirror.style.height = getRectHeight(rect) + 'px';\n    classes.rm(_mirror, 'gu-transit');\n    classes.add(_mirror, 'gu-mirror');\n    o.mirrorContainer.appendChild(_mirror);\n    touchy(documentElement, 'add', 'mousemove', drag);\n    classes.add(o.mirrorContainer, 'gu-unselectable');\n    drake.emit('cloned', _mirror, _item, 'mirror');\n  }\n\n  function removeMirrorImage () {\n    if (_mirror) {\n      classes.rm(o.mirrorContainer, 'gu-unselectable');\n      touchy(documentElement, 'remove', 'mousemove', drag);\n      getParent(_mirror).removeChild(_mirror);\n      _mirror = null;\n    }\n  }\n\n  function getImmediateChild (dropTarget, target) {\n    var immediate = target;\n    while (immediate !== dropTarget && getParent(immediate) !== dropTarget) {\n      immediate = getParent(immediate);\n    }\n    if (immediate === documentElement) {\n      return null;\n    }\n    return immediate;\n  }\n\n  function getReference (dropTarget, target, x, y) {\n    var horizontal = o.direction === 'horizontal';\n    var reference = target !== dropTarget ? inside() : outside();\n    return reference;\n\n    function outside () { // slower, but able to figure out any position\n      var len = dropTarget.children.length;\n      var i;\n      var el;\n      var rect;\n      for (i = 0; i < len; i++) {\n        el = dropTarget.children[i];\n        rect = el.getBoundingClientRect();\n        if (horizontal && (rect.left + rect.width / 2) > x) { return el; }\n        if (!horizontal && (rect.top + rect.height / 2) > y) { return el; }\n      }\n      return null;\n    }\n\n    function inside () { // faster, but only available if dropped inside a child element\n      var rect = target.getBoundingClientRect();\n      if (horizontal) {\n        return resolve(x > rect.left + getRectWidth(rect) / 2);\n      }\n      return resolve(y > rect.top + getRectHeight(rect) / 2);\n    }\n\n    function resolve (after) {\n      return after ? nextEl(target) : target;\n    }\n  }\n\n  function isCopy (item, container) {\n    return typeof o.copy === 'boolean' ? o.copy : o.copy(item, container);\n  }\n}\n\nfunction touchy (el, op, type, fn) {\n  var touch = {\n    mouseup: 'touchend',\n    mousedown: 'touchstart',\n    mousemove: 'touchmove'\n  };\n  var pointers = {\n    mouseup: 'pointerup',\n    mousedown: 'pointerdown',\n    mousemove: 'pointermove'\n  };\n  var microsoft = {\n    mouseup: 'MSPointerUp',\n    mousedown: 'MSPointerDown',\n    mousemove: 'MSPointerMove'\n  };\n  if (global.navigator.pointerEnabled) {\n    crossvent[op](el, pointers[type], fn);\n  } else if (global.navigator.msPointerEnabled) {\n    crossvent[op](el, microsoft[type], fn);\n  } else {\n    crossvent[op](el, touch[type], fn);\n    crossvent[op](el, type, fn);\n  }\n}\n\nfunction whichMouseButton (e) {\n  if (e.touches !== void 0) { return e.touches.length; }\n  if (e.which !== void 0 && e.which !== 0) { return e.which; } // see https://github.com/bevacqua/dragula/issues/261\n  if (e.buttons !== void 0) { return e.buttons; }\n  var button = e.button;\n  if (button !== void 0) { // see https://github.com/jquery/jquery/blob/99e8ff1baa7ae341e94bb89c3e84570c7c3ad9ea/src/event.js#L573-L575\n    return button & 1 ? 1 : button & 2 ? 3 : (button & 4 ? 2 : 0);\n  }\n}\n\nfunction getOffset (el) {\n  var rect = el.getBoundingClientRect();\n  return {\n    left: rect.left + getScroll('scrollLeft', 'pageXOffset'),\n    top: rect.top + getScroll('scrollTop', 'pageYOffset')\n  };\n}\n\nfunction getScroll (scrollProp, offsetProp) {\n  if (typeof global[offsetProp] !== 'undefined') {\n    return global[offsetProp];\n  }\n  if (documentElement.clientHeight) {\n    return documentElement[scrollProp];\n  }\n  return doc.body[scrollProp];\n}\n\nfunction getElementBehindPoint (point, x, y) {\n  point = point || {};\n  var state = point.className || '';\n  var el;\n  point.className += ' gu-hide';\n  el = doc.elementFromPoint(x, y);\n  point.className = state;\n  return el;\n}\n\nfunction never () { return false; }\nfunction always () { return true; }\nfunction getRectWidth (rect) { return rect.width || (rect.right - rect.left); }\nfunction getRectHeight (rect) { return rect.height || (rect.bottom - rect.top); }\nfunction getParent (el) { return el.parentNode === doc ? null : el.parentNode; }\nfunction isInput (el) { return el.tagName === 'INPUT' || el.tagName === 'TEXTAREA' || el.tagName === 'SELECT' || isEditable(el); }\nfunction isEditable (el) {\n  if (!el) { return false; } // no parents were editable\n  if (el.contentEditable === 'false') { return false; } // stop the lookup\n  if (el.contentEditable === 'true') { return true; } // found a contentEditable element in the chain\n  return isEditable(getParent(el)); // contentEditable is set to 'inherit'\n}\n\nfunction nextEl (el) {\n  return el.nextElementSibling || manually();\n  function manually () {\n    var sibling = el;\n    do {\n      sibling = sibling.nextSibling;\n    } while (sibling && sibling.nodeType !== 1);\n    return sibling;\n  }\n}\n\nfunction getEventHost (e) {\n  // on touchend event, we have to use `e.changedTouches`\n  // see http://stackoverflow.com/questions/7192563/touchend-event-properties\n  // see https://github.com/bevacqua/dragula/issues/34\n  if (e.targetTouches && e.targetTouches.length) {\n    return e.targetTouches[0];\n  }\n  if (e.changedTouches && e.changedTouches.length) {\n    return e.changedTouches[0];\n  }\n  return e;\n}\n\nfunction getCoord (coord, e) {\n  var host = getEventHost(e);\n  var missMap = {\n    pageX: 'clientX', // IE8\n    pageY: 'clientY' // IE8\n  };\n  if (coord in missMap && !(coord in host) && missMap[coord] in host) {\n    coord = missMap[coord];\n  }\n  return host[coord];\n}\n\nmodule.exports = dragula;\n"]},"metadata":{},"sourceType":"script"}